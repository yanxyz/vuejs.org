
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <title>组件 - vue.js</title>
        <meta charset="utf-8">
        <meta name="description" content="Vue.js - Intuitive, Fast and Composable MVVM for building interactive interfaces.">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
        <!-- <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600|Roboto Mono' rel='stylesheet' type='text/css'> -->
        <!-- <link href='http://fonts.googleapis.com/css?family=Dosis:300,500&text=Vue.js' rel='stylesheet' type='text/css'> -->
        <link rel="icon" href="http://vuejs.org/images/logo.png" type="image/x-icon">
        <script>
            window.PAGE_TYPE = "guide"
        </script>
        <link rel="stylesheet" href="http://vuejs.org/css/page.css" type="text/css">
        <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-46852172-1', 'vuejs.org');
  ga('send', 'pageview');
</script>
        <script src="http://vuejs.org/js/vue.js"></script>
    </head>
    <body>
        <div id="mobile-bar">
            <a class="menu-button"></a>
            <a class="logo" href="../"></a>
        </div>
        
            <div id="header">
    <a id="logo" href="../">
        <img src="http://vuejs.org/images/logo.png">
        <span>Vue.js</span>
    </a>
    <ul id="nav">
        <li>
  <form id="search-form">
    <input type="text" id="search-query" class="st-default-search-input">
  </form>
</li>
<li><a href="../guide/" class="nav-link current">教程</a></li>
<li><a href="../api/" class="nav-link">API</a></li>
<li><a href="../examples/" class="nav-link">示例</a></li>
<li><a href="http://vuejs.org/blog/" class="nav-link">博客</a></li>
<li class="nav-dropdown-container">
  <a class="nav-link">社区</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://github.com/vuejs/vue" class="nav-link" target="_blank">GitHub</a></li>
    <li><a href="http://forum.vuejs.org" class="nav-link" target="_blank">论坛</a></li>
    <li><a href="https://gitter.im/vuejs/vue" class="nav-link" target="_blank">聊天室</a></li>
    <li><a href="https://twitter.com/vuejs" class="nav-link" target="_blank">Twitter</a></li>
  </ul>
</li>


    </ul>
</div>
            <div id="main">
                
                    
    <div class="sidebar">
    <ul class="main-menu">
        <li>
  <form id="search-form">
    <input type="text" id="search-query" class="st-default-search-input">
  </form>
</li>
<li><a href="../guide/" class="nav-link current">教程</a></li>
<li><a href="../api/" class="nav-link">API</a></li>
<li><a href="../examples/" class="nav-link">示例</a></li>
<li><a href="http://vuejs.org/blog/" class="nav-link">博客</a></li>
<li class="nav-dropdown-container">
  <a class="nav-link">社区</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://github.com/vuejs/vue" class="nav-link" target="_blank">GitHub</a></li>
    <li><a href="http://forum.vuejs.org" class="nav-link" target="_blank">论坛</a></li>
    <li><a href="https://gitter.im/vuejs/vue" class="nav-link" target="_blank">聊天室</a></li>
    <li><a href="https://twitter.com/vuejs" class="nav-link" target="_blank">Twitter</a></li>
  </ul>
</li>


    </ul>
    <div class="list">
        <h2>
			
			教程
            <select class="version-select">
                <option selected>1.0</option>
                <option>0.12</option>
            </select>
        </h2>
        <ul class="menu-root">
            
                <li>
                    <a href="../guide/installation.html" class="sidebar-link">安装</a>
                </li>
            
                <li>
                    <a href="../guide/index.html" class="sidebar-link">起步</a>
                </li>
            
                <li>
                    <a href="../guide/overview.html" class="sidebar-link">概述</a>
                </li>
            
                <li>
                    <a href="../guide/instance.html" class="sidebar-link">Vue 实例</a>
                </li>
            
                <li>
                    <a href="../guide/syntax.html" class="sidebar-link">数据绑定语法</a>
                </li>
            
                <li>
                    <a href="../guide/computed.html" class="sidebar-link">计算属性</a>
                </li>
            
                <li>
                    <a href="../guide/class-and-style.html" class="sidebar-link">Class 与 Style 绑定</a>
                </li>
            
                <li>
                    <a href="../guide/conditional.html" class="sidebar-link">条件渲染</a>
                </li>
            
                <li>
                    <a href="../guide/list.html" class="sidebar-link">列表渲染</a>
                </li>
            
                <li>
                    <a href="../guide/events.html" class="sidebar-link">方法与事件处理器</a>
                </li>
            
                <li>
                    <a href="../guide/forms.html" class="sidebar-link">表单控件绑定</a>
                </li>
            
                <li>
                    <a href="../guide/transitions.html" class="sidebar-link">过渡</a>
                </li>
            
                <li>
                    <a href="../guide/components.html" class="sidebar-link current">组件</a>
                </li>
            
                <li>
                    <a href="../guide/reactivity.html" class="sidebar-link">深入响应式原理</a>
                </li>
            
                <li>
                    <a href="../guide/custom-directive.html" class="sidebar-link">自定义指令</a>
                </li>
            
                <li>
                    <a href="../guide/custom-filter.html" class="sidebar-link">自定义过滤器</a>
                </li>
            
                <li>
                    <a href="../guide/mixins.html" class="sidebar-link">混合</a>
                </li>
            
                <li>
                    <a href="../guide/plugins.html" class="sidebar-link">插件</a>
                </li>
            
                <li>
                    <a href="../guide/application.html" class="sidebar-link">构建大型应用</a>
                </li>
            
                <li>
                    <a href="../guide/comparison.html" class="sidebar-link">对比其它框架</a>
                </li>
            
        </ul>
        <div id="donate">
            <span class="wrapper" style="width: 110px">
              <img src="http://vuejs.org/images/paypal.png">
              <a href="https://www.paypal.me/evanyou" target="_blank">Buy Me Coffee</a>
            </span>
        </div>
    </div>
</div>


<div class="content guide with-sidebar">
    <h1>组件</h1>
    <div id="ad">
        <script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=vuejs" id="_carbonads_js"></script>
    </div>
    <h2 id="使用组件">使用组件</h2><h3 id="注册">注册</h3><p>之前说过，我们可以用 <code>Vue.extend()</code> 创建一个组件构造器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyComponent = Vue.extend(&#123;</span><br><span class="line">  <span class="comment">// 选项...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>要把这个构造器用作组件，需要用 <code>Vue.component(tag, constructor)</code> <strong>注册</strong> ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局注册组件，tag 为 my-component</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, MyComponent)</span><br></pre></td></tr></table></figure>
<p>在注册之后，组件便可以用在父实例的模块中，以自定义元素 <code>&lt;my-component&gt;</code> 的形式使用。要确保在初始化根实例<strong>之前</strong>注册了组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">my-component</span>&gt;</span><span class="tag">&lt;/<span class="title">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">var</span> MyComponent = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, MyComponent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建根实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>渲染为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span>&gt;</span>A custom component!<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div id="example" class="demo">
  <my-component></my-component>
</div>
<script>
Vue.component('my-component', {
  template: '<div>A custom component!</div>'
})
new Vue({ el: '#example' })
</script>

<p>注意组件的模板<strong>替换</strong>了自定义元素，自定义元素的作用只是作为一个<strong>挂载点</strong>。这可以用实例选项 <code>replace</code> 改变。</p>
<h3 id="局部注册">局部注册</h3><p>不需要全局注册每个组件。可以让组件只能用在其它组件内，用实例选项 <code>components</code> 注册：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Child = Vue.extend(&#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Parent = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="comment">// &lt;my-component&gt; 只能用在父组件模板内</span></span><br><span class="line">    <span class="string">'my-component'</span>: Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这种封装也适用于其它资源，如指令、过滤器和过渡。</p>
<h3 id="注册语法糖">注册语法糖</h3><p>为了让事件更简单，可以直接传入选项对象而不是构造器给 <code>Vue.component()</code> 和 <code>component</code> 选项。Vue.js 在背后自动调用 <code>Vue.extend()</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在一个步骤中扩展与注册</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部注册也可以这么做</span></span><br><span class="line"><span class="keyword">var</span> Parent = Vue.extend(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'my-component'</span>: &#123;</span><br><span class="line">      template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="组件选项问题">组件选项问题</h3><p>传入 Vue 构造器的多数选项也可以用在 <code>Vue.extend()</code> 中，不过有两个特例： <code>data</code> and <code>el</code>。试想如果我们简单地把一个对象作为 <code>data</code> 选项传给 <code>Vue.extend()</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; a: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> MyComponent = Vue.extend(&#123;</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这么做的问题是 <code>MyComponent</code> 所有的实例将共享同一个 <code>data</code> 对象！这基本不是我们想要的，因此我们应当使用一个函数作为 <code>data</code> 选项，函数返回一个新对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyComponent = Vue.extend(&#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; a: <span class="number">1</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>同理，<code>el</code> 选项用在 <code>Vue.extend()</code> 中时也须是一个函数。</p>
<h3 id="is_特性"><code>is</code> 特性</h3><p>一些 HTML 元素，如 <code>&lt;table&gt;</code>，限制什么元素可以放在它里面。自定义元素不在白名单上，将被放在元素的外面，因而渲染不正确。这时应当使用 <code>is</code> 特性，指示它是一个自定义元素：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">tr</span> <span class="attribute">is</span>=<span class="value">"my-component"</span>&gt;</span><span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Props">Props</h2><h3 id="使用_Props_传递数据">使用 Props 传递数据</h3><p><strong>组件实例的作用域是孤立的</strong>。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 <strong>props</strong> 把数据传给子组件。</p>
<p>“prop” 是组件数据的一个字段，期望从父组件传下来。子组件需要显式地用 <a href="../api/#props"><code>props</code> 选项</a> 声明 props：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  <span class="comment">// 声明 props</span></span><br><span class="line">  props: [<span class="string">'msg'</span>],</span><br><span class="line">  <span class="comment">// prop 可以用在模板内</span></span><br><span class="line">  <span class="comment">// 可以用 `this.msg` 设置</span></span><br><span class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后向它传入一个普通字符串：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">child</span> <span class="attribute">msg</span>=<span class="value">"hello!"</span>&gt;</span><span class="tag">&lt;/<span class="title">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong></p>

<div id="prop-example-1" class="demo">
  <child msg="hello!"></child>
</div>
<script>
new Vue({
  el: '#prop-example-1',
  components: {
    child: {
      props: ['msg'],
      template: '<span>{{ msg }}</span>'
    }
  }
})
</script>

<h3 id="camelCase_vs-_kebab-case">camelCase vs. kebab-case</h3><p>HTML 特性不区分大小写。名字形式为 camelCase 的 prop 用作特性时，需要转为 kebab-case（短横线隔开）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  <span class="comment">// camelCase in JavaScript</span></span><br><span class="line">  props: [<span class="string">'myMessage'</span>],</span><br><span class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- kebab-case in HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">child</span> <span class="attribute">my-message</span>=<span class="value">"hello!"</span>&gt;</span><span class="tag">&lt;/<span class="title">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="动态_Props">动态 Props</h3><p>类似于绑定一个普通的特性到一个表达式，也可以用 <code>v-bind</code> 绑定动态 Props 到父组件的数据。每当父组件的数据变化时，也会传导给子组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">input</span> <span class="attribute">v-model</span>=<span class="value">"parentMsg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">child</span> <span class="attribute">v-bind:my-message</span>=<span class="value">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="title">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>v-bind</code> 的缩写语法通常更简单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">child</span> <span class="attribute">:my-message</span>=<span class="value">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="title">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong></p>

<div id="demo-2" class="demo">
  <input v-model="parentMsg">
  <br>
  <child v-bind:my-message="parentMsg"></child>
</div>
<script>
new Vue({
  el: '#demo-2',
  data: {
    parentMsg: 'Message from parent'
  },
  components: {
    child: {
      props: ['myMessage'],
      template: '<span>{{myMessage}}</span>'
    }
  }
})
</script>

<h3 id="字面量语法_vs-_动态语法">字面量语法 vs. 动态语法</h3><p>初学者常犯的一个错误是使用字面量语法传递数值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 传递了一个字符串 "1" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">comp</span> <span class="attribute">some-prop</span>=<span class="value">"1"</span>&gt;</span><span class="tag">&lt;/<span class="title">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为它是一个字面 prop，它的值以字符串 <code>&quot;1&quot;</code> 而不是以实际的数字传下去。如果想传递一个实际的 JavaScript 数字，需要使用动态语法，从而让它的值被当作 JavaScript 表达式计算：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 传递实际的数字  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">comp</span> <span class="attribute">:some-prop</span>=<span class="value">"1"</span>&gt;</span><span class="tag">&lt;/<span class="title">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Prop_绑定类型">Prop 绑定类型</h3><p>prop 默认是<strong>单向</strong>绑定：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。不过，也可以使用 <code>.sync</code> 或 <code>.once</code> <strong>绑定修饰符</strong>显式地强制双向或单次绑定：</p>
<p>比较语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 默认为单向绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">child</span> <span class="attribute">:msg</span>=<span class="value">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="title">child</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 双向绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">child</span> <span class="attribute">:msg.sync</span>=<span class="value">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="title">child</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 单次绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">child</span> <span class="attribute">:msg.once</span>=<span class="value">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="title">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>双向绑定会把子组件的 <code>msg</code> 属性同步回父组件的 <code>parentMsg</code> 属性。单次绑定在建立之后不会同步之后的变化。</p>
<p class="tip">注意如果 prop 是一个对象或数组，是按引用传递。在子组件内修改它<strong>会</strong>影响父组件的状态，不管是使用哪种绑定类型。</p>

<h3 id="Prop_验证">Prop 验证</h3><p>组件可以为 props 指定验证要求。当组件给其他人使用时这很有用，因为这些验证要求构成了组件的 API，确保其他人正确地使用组件。此时 props 的值是一个对象，包含验证要求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'example'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 基础类型检测 （`null` 意思是任何类型都可以）</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 必需且是字符串</span></span><br><span class="line">    propB: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 数字，有默认值</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 对象/数组的默认值应当由一个函数返回</span></span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; msg: <span class="string">'hello'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 指定这个 prop 为双向绑定</span></span><br><span class="line">    <span class="comment">// 如果绑定类型不对将抛出一条警告</span></span><br><span class="line">    propE: &#123;</span><br><span class="line">      twoWay: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value &gt; <span class="number">10</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>type</code> 可以是下面原生构造器：</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Function</li>
<li>Object</li>
<li>Array</li>
</ul>
<p><code>type</code> 也可以是一个自定义构造器，使用 <code>instanceof</code> 检测。</p>
<p>当 prop 验证失败了，Vue 将拒绝在子组件上设置此值，如果使用的是开发版本会抛出一条警告。</p>
<h2 id="父子组件通信">父子组件通信</h2><h3 id="父链">父链</h3><p>子组件可以用 <code>this.$parent</code> 访问它的父组件。根实例的后代可以用 <code>this.$root</code> 访问它。父组件有一个数组 <code>this.$children</code>，包含它所有的子元素。</p>
<p>尽管可以访问父链上任意的实例，不过子组件应当避免直接依赖父组件的数据，应当显式地使用 props 传递数据。另外，在子组件中修改父组件的状态是非常糟糕的做法，因为：</p>
<ol>
<li><p>这让父组件与子组件紧密地耦合；</p>
</li>
<li><p>只看父组件，很难理解父组件的状态。因为它可能被任意子组件修改！理想情况下，只有组件自己能修改它的状态。</p>
</li>
</ol>
<h3 id="自定义事件">自定义事件</h3><p>Vue 实例实现了一个自定义事件接口，用于在组件树中通信。这个事件系统独立于原生 DOM 事件，做法也不同。</p>
<p>每个 Vue 实例都是一个事件触发器：</p>
<ul>
<li><p>使用 <code>$on()</code> 监听事件；</p>
</li>
<li><p>使用 <code>$emit()</code> 在它上面触发事件；</p>
</li>
<li><p>使用 <code>$dispatch()</code> 派发事件，事件沿着父链冒泡；</p>
</li>
<li><p>使用 <code>$broadcast()</code> 广播事件，事件向下传导给所有的后代。</p>
</li>
</ul>
<p class="tip">不同于 DOM 事件，Vue 事件在冒泡过程中第一次触发回调之后自动停止冒泡，除非回调明确返回 <code>true</code>。</p>

<p>简单例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">template</span> <span class="attribute">id</span>=<span class="value">"child-template"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">input</span> <span class="attribute">v-model</span>=<span class="value">"msg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">button</span> <span class="attribute">v-on:click</span>=<span class="value">"notify"</span>&gt;</span>Dispatch Event<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 父组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"events-example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">p</span>&gt;</span>Messages: &#123;&#123; messages | json &#125;&#125;<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">child</span>&gt;</span><span class="tag">&lt;/<span class="title">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册子组件</span></span><br><span class="line"><span class="comment">// 将当前消息派发出去</span></span><br><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  template: <span class="string">'#child-template'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; msg: <span class="string">'hello'</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    notify: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.msg.trim()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$dispatch(<span class="string">'child-msg'</span>, <span class="keyword">this</span>.msg)</span><br><span class="line">        <span class="keyword">this</span>.msg = <span class="string">''</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动父组件</span></span><br><span class="line"><span class="comment">// 将收到消息时将事件推入一个数组</span></span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#events-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    messages: []</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 在创建实例时 `events` 选项简单地调用 `$on`</span></span><br><span class="line">  events: &#123;</span><br><span class="line">    <span class="string">'child-msg'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 事件回调内的 `this` 自动绑定到注册它的实例上</span></span><br><span class="line">      <span class="keyword">this</span>.messages.push(msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<template id="child-template">
  <input v-model="msg">
  <button v-on:click="notify">Dispatch Event</button>
</template>

<div id="events-example" class="demo">
  <p>Messages: {{ messages | json }}</p>
  <child></child>
</div>
<script>
Vue.component('child', {
  template: '#child-template',
  data: function () {
    return { msg: 'hello' }
  },
  methods: {
    notify: function () {
      if (this.msg.trim()) {
        this.$dispatch('child-msg', this.msg)
        this.msg = ''
      }
    }
  }
})

var parent = new Vue({
  el: '#events-example',
  data: {
    messages: []
  },
  events: {
    'child-msg': function (msg) {
      this.messages.push(msg)
    }
  }
})
</script>

<h3 id="使用_v-on_绑定自定义事件">使用 v-on 绑定自定义事件</h3><p>上例非常好，不过看着父组件的代码， <code>&quot;child-msg&quot;</code> 事件来自哪里不直观。如果我们在模板中子组件用到的地方声明事件处理器会更好。为了做到这点，子组件可以用 <code>v-on</code> 监听自定义事件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">child</span> <span class="attribute">v-on:child-msg</span>=<span class="value">"handleIt"</span>&gt;</span><span class="tag">&lt;/<span class="title">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这让事情非常清晰：当子组件触发了 <code>&quot;child-msg&quot;</code> 事件，父组件的 <code>handleIt</code> 方法将被调用。所有影响父组件状态的代码放到父组件的 <code>handleIt</code> 方法中；子组件只关注触发事件。</p>
<h3 id="子组件索引">子组件索引</h3><p>尽管有 props 和 events，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 <code>v-ref</code> 为子组件指定一个索引 ID。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">user-profile</span> <span class="attribute">v-ref:profile</span>&gt;</span><span class="tag">&lt;/<span class="title">user-profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Vue(&#123; el: <span class="string">'#parent'</span> &#125;)</span><br><span class="line"><span class="comment">// 访问子组件</span></span><br><span class="line"><span class="keyword">var</span> child = parent.$refs.profile</span><br></pre></td></tr></table></figure>
<p><code>v-ref</code> 和 <code>v-for</code> 一起用时，ref 是一个数组或对象，包含相应的子组件。</p>
<h2 id="使用_Slot_分发内容">使用 Slot 分发内容</h2><p>在使用组件时，常常要像这样组合它们：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">app-header</span>&gt;</span><span class="tag">&lt;/<span class="title">app-header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">app-footer</span>&gt;</span><span class="tag">&lt;/<span class="title">app-footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意两点：</p>
<ol>
<li><p><code>&lt;app&gt;</code> 组件不知道它的挂载会有什么内容。这取决于 <code>&lt;app&gt;</code> 的父组件。</p>
</li>
<li><p><code>&lt;app&gt;</code> 组件很可能有它自己的模板。</p>
</li>
</ol>
<p>为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个处理称为<strong>内容分发</strong>（或 “transclusion”，如果你熟悉 Angular）。Vue.js 实现了一个内容分发 API，参照了当前 <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md" target="_blank" rel="external">Web 组件规范草稿</a>，使用特殊的 <code>&lt;slot&gt;</code> 元素作为原始内容的插槽。</p>
<h3 id="编译作用域">编译作用域</h3><p>在深入内容分发 API 之前，我们先明确内容的编译作用域。假定模板为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">child</span>&gt;</span></span><br><span class="line">  &#123;&#123; msg &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="title">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>msg</code> 应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。组件作用域简单地说是：</p>
<blockquote>
<p>父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译</p>
</blockquote>
<p>一个常见错误是试图在父组件模板内将一个指令绑定到子组件属性/方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 无效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">child</span> <span class="attribute">v-show</span>=<span class="value">"someChildProperty"</span>&gt;</span><span class="tag">&lt;/<span class="title">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>假定 <code>someChildProperty</code> 是子组件的属性，上例不能如预期工作。父组件模板不知道子组件的状态。</p>
<p>如果要绑定子组件内的指令到一个组件的根节点，应当在它的模板内这么做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-component'</span>, &#123;</span><br><span class="line">  <span class="comment">// 有效，因为是在正确的作用域内</span></span><br><span class="line">  template: <span class="string">'&lt;div v-show="someChildProperty"&gt;Child&lt;/div&gt;'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      someChildProperty: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>类似地，分发内容是在父组件作用域内编译。</p>
<h3 id="单个_Slot">单个 Slot</h3><p>父组件的内容将被<strong>抛弃</strong>，除非子组件模板包含 <code>&lt;slot&gt;</code>。如果只有一个没有特性的 slot，整个内容将被插到它所在的地方，替换 slot。</p>
<p><code>&lt;slot&gt;</code> 标签的内容视为<strong>回退内容</strong>。回退内容在子组件的作用域内编译，只有当宿主元素为空并且没有内容供插入时显示。</p>
<p>假定 <code>my-component</code> 组件有下面模板：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">h1</span>&gt;</span>This is my component!<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">slot</span>&gt;</span></span><br><span class="line">    This will only be displayed if there is no content</span><br><span class="line">    to be distributed.</span><br><span class="line">  <span class="tag">&lt;/<span class="title">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>父组件模板：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">my-component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">p</span>&gt;</span>This is some original content<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">p</span>&gt;</span>This is some more original content<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>渲染结果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">h1</span>&gt;</span>This is my component!<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">p</span>&gt;</span>This is some original content<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">p</span>&gt;</span>This is some more original content<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="命名_Slot">命名 Slot</h3><p><code>&lt;slot&gt;</code> 元素有一个特殊特性 <code>name</code>，用于配置如何分发内容。多个 slot 可以有不同的名字。命名 slot 将匹配有对应 <code>slot</code> 特性的内容片断。</p>
<p>也可以有一个未命名 slot，它是<strong>默认 slot</strong>，作为找不到匹配内容的回退插槽。如果没有默认的 slot，不匹配内容将被抛弃。</p>
<p>例如，假定我们有一个 <code>multi-insertion</code> 组件，它的模板为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">slot</span> <span class="attribute">name</span>=<span class="value">"one"</span>&gt;</span><span class="tag">&lt;/<span class="title">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">slot</span>&gt;</span><span class="tag">&lt;/<span class="title">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">slot</span> <span class="attribute">name</span>=<span class="value">"two"</span>&gt;</span><span class="tag">&lt;/<span class="title">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>父组件模板：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">multi-insertion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">p</span> <span class="attribute">slot</span>=<span class="value">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">p</span> <span class="attribute">slot</span>=<span class="value">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">p</span>&gt;</span>Default A<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">multi-insertion</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>渲染结果为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">p</span> <span class="attribute">slot</span>=<span class="value">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">p</span>&gt;</span>Default A<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">p</span> <span class="attribute">slot</span>=<span class="value">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在组合组件时，内容分发 API 是非常有用的机制。</p>
<h2 id="动态组件">动态组件</h2><p>多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留的 <code>&lt;component&gt;</code> 元素，动态地绑定到它的 <code>is</code> 特性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'body'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    currentView: <span class="string">'home'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    home: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">    posts: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">    archive: &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">component</span> <span class="attribute">:is</span>=<span class="value">"currentView"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 组件在 vm.currentview 变化时改变 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 <code>keep-alive</code> 指令参数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">component</span> <span class="attribute">:is</span>=<span class="value">"currentView"</span> <span class="attribute">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 非活动组件将被缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="activate_钩子"><code>activate</code> 钩子</h3><p>在切换组件时，切入组件在切入前可能需要进行一些异步操作。为了控制组件切换时长，给切入组件添加 <code>activate</code> 钩子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'activate-example'</span>, &#123;</span><br><span class="line">  activate: <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">    loadDataAsync(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      self.someData = data</span><br><span class="line">      done()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意 <code>activate</code> 钩子只作用于动态组件切换或静态组件初始化渲染的过程中，不作用于使用实例方法手工插入的过程中。</p>
<h3 id="transition-mode"><code>transition-mode</code></h3><p><code>transition-mode</code> 特性用于指定两个动态组件之间如何过渡。</p>
<p>在默认情况下，进入与离开平滑地过渡。这个特性可以指定另外两种模式：</p>
<ul>
<li><p><code>in-out</code>：新组件先过渡进入，等它的过渡完成之后当前组件过渡出去。</p>
</li>
<li><p><code>out-in</code>：当前组件先过渡出去，等它的过渡完成之后新组件过渡进入。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 先淡出再淡入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">component</span></span><br><span class="line">  <span class="attribute">:is</span>=<span class="value">"view"</span></span><br><span class="line">  <span class="attribute">transition</span>=<span class="value">"fade"</span></span><br><span class="line">  <span class="attribute">transition-mode</span>=<span class="value">"out-in"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="class">.fade-transition</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">transition</span>:<span class="value"> opacity .<span class="number">3s</span> ease</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.fade-enter</span>, <span class="class">.fade-leave</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">opacity</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>

<div id="transition-mode-demo" class="demo">
  <input v-model="view" type="radio" value="v-a" id="a" name="view"><label for="a">A</label>
  <input v-model="view" type="radio" value="v-b" id="b" name="view"><label for="b">B</label>
  <component :is="view" transition="fade" transition-mode="out-in">
  </component>
</div>
<style>
  .fade-transition {
    transition: opacity .3s ease;
  }
  .fade-enter, .fade-leave {
    opacity: 0;
  }
</style>
<script>
new Vue({
  el: '#transition-mode-demo',
  data: {
    view: 'v-a'
  },
  components: {
    'v-a': {
      template: '<div>Component A</div>'
    },
    'v-b': {
      template: '<div>Component B</div>'
    }
  }
})
</script>

<h2 id="杂项">杂项</h2><h3 id="组件和_v-for">组件和 v-for</h3><p>自定义组件可以像普通元素一样直接使用  <code>v-for</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">my-component</span> <span class="attribute">v-for</span>=<span class="value">"item in items"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是，不能传递数据给组件，因为组件的作用域是孤立的。为了传递数据给组件，应当使用 props：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">my-component</span></span><br><span class="line">  <span class="attribute">v-for</span>=<span class="value">"item in items"</span></span><br><span class="line">  <span class="attribute">:item</span>=<span class="value">"item"</span></span><br><span class="line">  <span class="attribute">:index</span>=<span class="value">"$index"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不自动把 <code>item</code> 注入组件的原因是这会导致组件跟当前 <code>v-for</code> 紧密耦合。显式声明数据来自哪里可以让组件复用在其它地方。</p>
<h3 id="编写可复用组件">编写可复用组件</h3><p>在编写组件时，记住是否要复用组件有好处。一次性组件跟其它组件紧密耦合没关系，但是可复用组件应当定义一个清晰的公开接口。</p>
<p>Vue.js 组件 API 来自三部分——prop，事件和 slot：</p>
<ul>
<li><p><strong>prop</strong> 允许外部环境传递数据给组件；</p>
</li>
<li><p><strong>事件</strong> 允许组件触发外部环境的 action；</p>
</li>
<li><p><strong>slot</strong> 允许外部环境插入内容到组件的视图结构内。</p>
</li>
</ul>
<p>使用 <code>v-bind</code> 和 <code>v-on</code> 的简写语法，模板的缩进清楚且简洁：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">my-component</span></span><br><span class="line">  <span class="attribute">:foo</span>=<span class="value">"baz"</span></span><br><span class="line">  <span class="attribute">:bar</span>=<span class="value">"qux"</span></span><br><span class="line">  @<span class="attribute">event-a</span>=<span class="value">"doThis"</span></span><br><span class="line">  @<span class="attribute">event-b</span>=<span class="value">"doThat"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- content --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">img</span> <span class="attribute">slot</span>=<span class="value">"icon"</span> <span class="attribute">src</span>=<span class="value">"..."</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">p</span> <span class="attribute">slot</span>=<span class="value">"main-text"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="异步组件">异步组件</h3><p>在大型应用中，我们可能需要将应用拆分为小块，只在需要时才从服务器下载。为了让事情更简单，Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    resolve(&#123;</span><br><span class="line">      template: <span class="string">'&lt;div&gt;I am async!&lt;/div&gt;'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>工厂函数接收一个 <code>resolve</code> 回调，在收到从服务器下载的组件定义时调用。也可以调用 <code>reject(reason)</code> 指示加载失败。这里 <code>setTimeout</code> 只是为了演示。怎么获取组件完全由你决定。推荐配合使用 <a href="http://webpack.github.io/docs/code-splitting.html" target="_blank" rel="external">Webpack 的代码分割功能</a>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-webpack-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个特殊的 require 语法告诉 webpack</span></span><br><span class="line">  <span class="comment">// 自动将编译后的代码分割成不同的块，</span></span><br><span class="line">  <span class="comment">// 这些块将通过 ajax 请求自动下载。</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">'./my-async-component'</span>], resolve)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="资源命名约定">资源命名约定</h3><p>一些资源，如组件和指令，是以 HTML 特性或 HTML 自定义元素的形式出现在模板中。因为 HTML 特性的名字和标签的名字<strong>不区分大小写</strong>，所以资源的名字通常需使用 kebab-case 而不是 camelCase 的形式，这不大方便。</p>
<p>Vue.js 支持资源的名字使用 camelCase 或 PascalCase 的形式，并且在模板中自动将它们转为 kebab-case（类似于 prop 的命名约定）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在组件定义中</span></span><br><span class="line">components: &#123;</span><br><span class="line">  <span class="comment">// 使用 camelCase 形式注册</span></span><br><span class="line">  myComponent: &#123; <span class="comment">/*... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在模板中使用 kebab-case 形式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">my-component</span>&gt;</span><span class="tag">&lt;/<span class="title">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_6" target="_blank" rel="external">ES6 对象字面量缩写</a> 也没问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PascalCase</span></span><br><span class="line"><span class="keyword">import</span> TextBox <span class="keyword">from</span> <span class="string">'./components/text-box'</span>;</span><br><span class="line"><span class="keyword">import</span> DropdownMenu <span class="keyword">from</span> <span class="string">'./components/dropdown-menu'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="comment">// 在模板中写作 &lt;text-box&gt; 和 &lt;dropdown-menu&gt;</span></span><br><span class="line">    TextBox,</span><br><span class="line">    DropdownMenu</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归组件">递归组件</h3><p>组件在它的模板内可以递归地调用自己，不过，只有当它有 <code>name</code> 选项时才可以：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> StackOverflow = Vue.extend(&#123;</span><br><span class="line">  name: <span class="string">'stack-overflow'</span>,</span><br><span class="line">  template:</span><br><span class="line">    <span class="string">'&lt;div&gt;'</span> +</span><br><span class="line">      <span class="comment">// 递归地调用它自己</span></span><br><span class="line">      <span class="string">'&lt;stack-overflow&gt;&lt;/stack-overflow&gt;'</span> +</span><br><span class="line">    <span class="string">'&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面组件会导致一个错误 “max stack size exceeded”，所以要确保递归调用有终止条件。当使用 <code>Vue.component()</code> 全局注册一个组件时，组件 ID 自动设置为组件的 <code>name</code> 选项。</p>
<h3 id="片断实例">片断实例</h3><p>在使用 <code>template</code> 选项时，模板的内容将替换实例的挂载元素。因而推荐模板的顶级元素始终是单个元素。</p>
<p>下面几种情况会让实例变成一个<strong>片断实例</strong>：</p>
<ol>
<li>模板包含多个顶级元素。</li>
<li>模板只包含普通文本。</li>
<li>模板只包含其它组件。</li>
<li>模板只包含一个元素指令，如 <code>&lt;partial&gt;</code> 或 vue-router 的 <code>&lt;router-view&gt;</code>。</li>
<li>模板根节点有一个流程控制指令，如 <code>v-if</code> 或 <code>v-for</code>。</li>
</ol>
<p>这些情况让实例有未知数量的顶级元素，它将把它的 DOM 内容当作片断。片断实例仍然会正确地渲染内容。不过，它<strong>没有</strong>一个根节点，它的 <code>$el</code> 指向一个锚节点，即一个空的文本节点（在开发模式下是一个注释节点）。</p>
<p>但是更重要的是，<strong>组件元素上的非流程控制指令，非 prop 特性和过渡将被忽略</strong>，因为没有根元素供绑定：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不可以，因为没有根元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">example</span> <span class="attribute">v-show</span>=<span class="value">"ok"</span> <span class="attribute">transition</span>=<span class="value">"fade"</span>&gt;</span><span class="tag">&lt;/<span class="title">example</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- props 可以 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">example</span> <span class="attribute">:prop</span>=<span class="value">"someData"</span>&gt;</span><span class="tag">&lt;/<span class="title">example</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 流程控制可以，但是不能有过渡 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">example</span> <span class="attribute">v-if</span>=<span class="value">"ok"</span>&gt;</span><span class="tag">&lt;/<span class="title">example</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然片断实例有它的用处，不过通常给组件一个根节点比较好。它会保证组件元素上的指令和特性能正确地转换，同时性能也稍微好些。</p>
<h3 id="内联模板">内联模板</h3><p>如果子组件有 <code>inline-template</code> 特性，组件将把它的内容当作它的模块，而不是把它当作分发内容。这让模板更灵活。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">my-component</span> <span class="attribute">inline-template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">p</span>&gt;</span>These are compiled as the component's own template<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">p</span>&gt;</span>Not parent's transclusion content.<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是 <code>inline-template</code> 让模板的作用域难以理解，并且不能缓存模板编译结果。最佳实践是使用 <code>template</code> 选项在组件内定义模板。</p>

    
      <div class="guide-links">
        
          <span>← <a href="../guide/transitions.html">过渡</a></span>
        
        
          <span style="float:right"><a href="../guide/reactivity.html">深入响应式原理</a> →</span>
        
      </div>
    
    <div class="footer">发现错误？想参与编辑？<a href="https://github.com/vuejs/cn.vuejs.org" target="_blank">来 Github 上 fork 此站点！</a></div>
</div>

                
            </div>
            <script src="http://vuejs.org/js/smooth-scroll.min.js"></script>
            <script src="http://vuejs.org/js/common.js"></script>
        

        <script src="https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                FastClick.attach(document.body);
            }, false);
        </script>
    </body>
</html>
